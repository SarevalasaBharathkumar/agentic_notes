import {import {

  Dialog,  Dialog,

  DialogContent,  DialogContent,

  DialogHeader,  DialogHeader,

  DialogTitle,  DialogTitle,

  DialogDescription,  DialogDescription,

} from "@/components/ui/dialog";} from "@/components/ui/dialog";

import { Button } from "@/components/ui/button";import { Button } from "@/components/ui/button";

import { ScrollArea } from "@/components/ui/scroll-area";import { ScrollArea } from "@/components/ui/scroll-area";

import { Input } from "@/components/ui/input";// Replaced textarea with a rich editor

import { useState, useEffect } from "react";import { Input } from "@/components/ui/input";

import { supabase } from "@/integrations/supabase/client";import { useState, useEffect } from "react";

import { generateTitle } from "@/lib/gemini";import { supabase } from "@/integrations/supabase/client";

import React from "react";import { generateTitle } from "@/lib/gemini";

import { RichNoteEditor } from "@/components/RichNoteEditor";import React from "react";

import { offline } from "@/lib/offline";// markdown-to-html handled within rich editor for initialization

import {import { RichNoteEditor } from "@/components/RichNoteEditor";

  AlertDialog,import { offline } from "@/lib/offline";

  AlertDialogAction,import {

  AlertDialogCancel,  AlertDialog,

  AlertDialogContent,  AlertDialogAction,

  AlertDialogDescription,  AlertDialogCancel,

  AlertDialogFooter,  AlertDialogContent,

  AlertDialogHeader,  AlertDialogDescription,

  AlertDialogTitle,  AlertDialogFooter,

} from "@/components/ui/alert-dialog";  AlertDialogHeader,

  AlertDialogTitle,

interface Note {} from "@/components/ui/alert-dialog";

  id: string;

  title: string;interface Note {

  content: string;  id: string;

  updated_at: string;  title: string;

  user_id: string;  content: string;

}  updated_at: string;

  user_id: string;

interface NoteDialogProps {}

  note?: Note;

  open: boolean;interface NoteDialogProps {

  onOpenChange: (open: boolean) => void;  note?: Note;

  onUpdateNote?: (note: Partial<Note> | null) => void;  open: boolean;

  userId?: string;  onOpenChange: (open: boolean) => void;

}  onUpdateNote?: (note: Partial<Note> | null) => void;

  userId?: string;

export const NoteDialog = ({ note, open, onOpenChange, onUpdateNote, userId }: NoteDialogProps) => {}

  const [title, setTitle] = useState(note?.title ?? "");

  const [content, setContent] = useState(note?.content ?? "");export const NoteDialog = ({ note, open, onOpenChange, onUpdateNote, userId }: NoteDialogProps) => {

  const [originalTitle, setOriginalTitle] = useState(note?.title ?? "");  const [title, setTitle] = useState(note?.title ?? "");

  const [originalContent, setOriginalContent] = useState(note?.content ?? "");  const [content, setContent] = useState(note?.content ?? "");

  const [saving, setSaving] = useState(false);  const [originalTitle, setOriginalTitle] = useState(note?.title ?? "");

  const [hasChanges, setHasChanges] = useState(false);  const [originalContent, setOriginalContent] = useState(note?.content ?? "");

  const [confirmClose, setConfirmClose] = useState(false);  const [saving, setSaving] = useState(false);

  const [isEditMode, setIsEditMode] = useState(!note); // Start in edit mode for new notes only  const [hasChanges, setHasChanges] = useState(false);

  const [confirmClose, setConfirmClose] = useState(false);

  // Reset form when note changes  const [isEditMode, setIsEditMode] = useState(!note); // Start in edit mode for new notes only

  useEffect(() => {  // Textarea removed; rich editor handles formatting interactions

    if (note) {

      setTitle(note.title);  // Reset form when note changes

      setContent(note.content);  useEffect(() => {

      setOriginalTitle(note.title ?? "");    if (note) {

      setOriginalContent(note.content ?? "");      setTitle(note.title);

      setIsEditMode(false); // Start in view mode for existing notes      setContent(note.content);

    } else {      setOriginalTitle(note.title ?? "");

      setTitle("");      setOriginalContent(note.content ?? "");

      setContent("");      setIsEditMode(false); // Start in view mode for existing notes

      setOriginalTitle("");    } else {

      setOriginalContent("");      setTitle("");

      setIsEditMode(true); // Start in edit mode for new notes      setContent("");

    }      setOriginalTitle("");

    setHasChanges(false);      setOriginalContent("");

  }, [note]);      setIsEditMode(true); // Start in edit mode for new notes

    }

  // Save note function    setHasChanges(false);

  const saveNote = async () => {  }, [note]);

    setSaving(true);

    const timestamp = new Date().toISOString();  // Save note function

  const saveNote = async () => {

    // Prepare the update data    setSaving(true);

    // Auto-generate a title when missing but content exists    const timestamp = new Date().toISOString();

    let titleToSave = (title || "").trim();

    const plainContent = (content || "").replace(/<[^>]*>/g, " ").trim();    // Prepare the update data

    try {    // Auto-generate a title when missing but content exists

      // If there are no changes, do nothing and treat as saved    let titleToSave = (title || "").trim();

      const norm = (s: string) => (s || "").replace(/\s+/g, ' ').trim();    const plainContent = (content || "").replace(/<[^>]*>/g, " ").trim();

      const changed = norm(title) !== norm(originalTitle) || norm(content) !== norm(originalContent);    try {

      if (!changed) {      // If there are no changes, do nothing and treat as saved

        setHasChanges(false);      const norm = (s: string) => (s || "").replace(/\s+/g, ' ').trim();

        return true;      const changed = norm(title) !== norm(originalTitle) || norm(content) !== norm(originalContent);

      }      if (!changed) {

        setHasChanges(false);

      if (!titleToSave && plainContent) {        return true;

        const online = typeof navigator !== 'undefined' && navigator.onLine;      }

        if (online) {

          // Try AI title only when online; otherwise fall back instantly      if (!titleToSave && plainContent) {

          titleToSave = (await generateTitle(content)).trim() || "Untitled";        const online = typeof navigator !== 'undefined' && navigator.onLine;

        } else {        if (online) {

          // Fast local title: first 60 chars of plain text          // Try AI title only when online; otherwise fall back instantly

          titleToSave = (plainContent.slice(0, 60) + (plainContent.length > 60 ? '…' : '')).trim() || "Untitled";          titleToSave = (await generateTitle(content)).trim() || "Untitled";

        }        } else {

        setTitle(titleToSave);          // Fast local title: first 60 chars of plain text

      }          titleToSave = (plainContent.slice(0, 60) + (plainContent.length > 60 ? '…' : '')).trim() || "Untitled";

    } catch (e) {        }

      // Fallback if generation fails        setTitle(titleToSave);

      titleToSave = titleToSave || (plainContent ? (plainContent.slice(0, 60) + (plainContent.length > 60 ? '...' : '')).trim() : "");      }

      setTitle(titleToSave);    } catch (e) {

    }      // Fallback if generation fails

      titleToSave = titleToSave || (plainContent ? (plainContent.slice(0, 60) + (plainContent.length > 60 ? '...' : '')).trim() : "");

    const updateData = {      setTitle(titleToSave);

      title: titleToSave,    }

      content,

      updated_at: timestamp    const updateData = {

    };      title: titleToSave,

    try {      content,

      // If empty content/title: do not save. If existing note, delete it.      updated_at: timestamp

      const isEmpty = !titleToSave && !content?.replace(/<[^>]*>/g, '').trim();    };

      if (isEmpty) {    try {

        if (note?.id) {      // If empty content/title: do not save. If existing note, delete it.

          if (navigator.onLine) {      const isEmpty = !titleToSave && !content?.replace(/<[^>]*>/g, '').trim();

            const { error } = await supabase      if (isEmpty) {

              .from("notes")        if (note?.id) {

              .delete()          if (navigator.onLine) {

              .eq("id", note.id);            const { error } = await supabase

            if (error) throw error;              .from("notes")

            // Mirror deletion to local store when online              .delete()

            await offline.deleteLocalNote(note.id);              .eq("id", note.id);

          } else if (userId) {            if (error) throw error;

            await offline.deleteLocalNote(note.id);            // Mirror deletion to local store when online

            await offline.queueDelete(note.id, userId);            await offline.deleteLocalNote(note.id);

          }          } else if (userId) {

          onUpdateNote?.(null);            await offline.deleteLocalNote(note.id);

        }            await offline.queueDelete(note.id, userId);

        setHasChanges(false);          }

        return true;          onUpdateNote?.(null as any);

      }        }

        setHasChanges(false);

      if (note?.id) {        return true;

        // Update existing note      }

        if (navigator.onLine) {

          const { error } = await supabase      if (note?.id) {

            .from("notes")        // Update existing note

            .update(updateData)        if (navigator.onLine) {

            .eq("id", note.id);          const { error } = await supabase

          if (error) throw error;            .from("notes")

          // Keep local store in sync            .update(updateData)

          const localNote = { id: note.id, user_id: note.user_id, ...updateData } as Note;            .eq("id", note.id);

          await offline.putLocalNote(localNote as any);          if (error) throw error;

        } else if (userId) {          // Keep local store in sync

          const localNote = { id: note.id, user_id: userId, ...updateData } as Note;          const localNote = { id: note.id, user_id: note.user_id, ...updateData } as Note;

          await offline.putLocalNote(localNote as any);          await offline.putLocalNote(localNote as any);

          await offline.queueUpsert(localNote as any);        } else if (userId) {

        }          const localNote = { id: note.id, user_id: userId, ...updateData } as Note;

        // Immediately reflect in UI          await offline.putLocalNote(localNote as any);

        onUpdateNote?.({ id: note.id, ...updateData });          await offline.queueUpsert(localNote as any);

      } else {        }

        // Create new note        // Immediately reflect in UI

        let effectiveUserId = userId;        onUpdateNote?.({ id: note.id, ...updateData });

        if (!effectiveUserId) {      } else {

          const { data } = await supabase.auth.getUser();        // Create new note

          effectiveUserId = data.user?.id;        let effectiveUserId = userId;

        }        if (!effectiveUserId) {

        if (!effectiveUserId) throw new Error("User not authenticated");          const { data } = await supabase.auth.getUser();

          effectiveUserId = data.user?.id;

        if (navigator.onLine) {        }

          const { data, error } = await supabase        if (!effectiveUserId) throw new Error("User not authenticated");

            .from("notes")

            .insert({        if (navigator.onLine) {

              ...updateData,          const { data, error } = await supabase

              user_id: effectiveUserId,            .from("notes")

            })            .insert({

            .select()              ...updateData,

            .single();              user_id: effectiveUserId,

          if (error) throw error;            })

          if (data) await offline.putLocalNote(data as any);            .select()

          if (data && onUpdateNote) onUpdateNote(data);            .single();

        } else {          if (error) throw error;

          const id = offline.makeId();          if (data) await offline.putLocalNote(data as any);

          const localNote = { id, user_id: effectiveUserId, ...updateData } as Note;          if (data && onUpdateNote) onUpdateNote(data);

          await offline.putLocalNote(localNote as any);        } else {

          await offline.queueUpsert(localNote as any);          const id = offline.makeId();

          onUpdateNote?.(localNote);          const localNote = { id, user_id: effectiveUserId, ...updateData } as Note;

        }          await offline.putLocalNote(localNote as any);

      }          await offline.queueUpsert(localNote as any);

      setHasChanges(false);          onUpdateNote?.(localNote);

      return true;        }

    } catch (error) {      }

      console.error("Error saving note:", error);      setHasChanges(false);

      return false;      return true;

    } finally {    } catch (error) {

      setSaving(false);      console.error("Error saving note:", error);

    }      return false;

  };    } finally {

      setSaving(false);

  useEffect(() => {    }

    const norm = (s: string) => (s || "").replace(/\s+/g, ' ').trim();  };

    const changed = norm(title) !== norm(originalTitle) || norm(content) !== norm(originalContent);

    setHasChanges(changed);  useEffect(() => {

  }, [title, content, originalTitle, originalContent]);    const norm = (s: string) => (s || "").replace(/\s+/g, ' ').trim();

    const changed = norm(title) !== norm(originalTitle) || norm(content) !== norm(originalContent);

  const handleSuggestTitle = async () => {    setHasChanges(changed);

    if (!content) return;  }, [title, content, originalTitle, originalContent]);

    setSaving(true);

    try {  const handleSuggestTitle = async () => {

      const suggestedTitle = await generateTitle(content);    if (!content) return;

      setTitle(suggestedTitle);    setSaving(true);

    } catch (error) {    try {

      console.error("Error generating title:", error);      const suggestedTitle = await generateTitle(content);

    } finally {      setTitle(suggestedTitle);

      setSaving(false);    } catch (error) {

    }      console.error("Error generating title:", error);

  };    } finally {

      setSaving(false);

  return (    }

    <>  };

      <Dialog open={open} onOpenChange={(isOpen) => {

        if (!isOpen && hasChanges) {  return (

          setConfirmClose(true);    <Dialog open={open} onOpenChange={(isOpen) => {

          return;      if (!isOpen && hasChanges) {

        }        setConfirmClose(true);

        onOpenChange(isOpen);        return;

      }}>      }

        <DialogContent       onOpenChange(isOpen);

          className="max-w-3xl h-[80vh] flex flex-col p-0"    }}>

        >      <DialogContent 

          <DialogHeader className="p-4 border-b">        className="max-w-3xl h-[80vh] flex flex-col p-0"

            <DialogTitle className="sr-only">      >

              {note ? "Edit Note" : "Create New Note"}        <DialogHeader className="p-4 border-b">

            </DialogTitle>          <DialogTitle className="sr-only">

            <DialogDescription className="sr-only">            {note ? "Edit Note" : "Create New Note"}

              Use this dialog to create or edit your note. Enter a title and content for your note.          </DialogTitle>

            </DialogDescription>          <DialogDescription className="sr-only">

            <div className="flex items-center gap-2">            Use this dialog to create or edit your note. Enter a title and content for your note.

              {isEditMode ? (          </DialogDescription>

                <Input          <div className="flex items-center gap-2">

                  value={title}            {isEditMode ? (

                  onChange={(e) => setTitle(e.target.value)}              <Input

                  placeholder="Note title..."                value={title}

                  className="text-xl font-semibold bg-transparent border-0 p-0 focus-visible:ring-0"                onChange={(e) => setTitle(e.target.value)}

                  aria-label="Note title"                placeholder="Note title..."

                />                className="text-xl font-semibold bg-transparent border-0 p-0 focus-visible:ring-0"

              ) : (                aria-label="Note title"

                <div className="text-xl font-semibold flex-grow">{title || "Untitled Note"}</div>              />

              )}            ) : (

              {note && (              <div className="text-xl font-semibold flex-grow">{title || "Untitled Note"}</div>

                <Button            )}

                  variant="ghost"            {note && ( // Only show edit button for existing notes

                  size="icon"              <Button

                  onClick={() => setIsEditMode(!isEditMode)}                variant="ghost"

                  className="h-8 w-8"                size="icon"

                >                onClick={() => setIsEditMode(!isEditMode)}

                  <svg                className="h-8 w-8"

                    xmlns="http://www.w3.org/2000/svg"              >

                    viewBox="0 0 24 24"                <svg

                    fill="none"                  xmlns="http://www.w3.org/2000/svg"

                    stroke="currentColor"                  viewBox="0 0 24 24"

                    strokeWidth="2"                  fill="none"

                    strokeLinecap="round"                  stroke="currentColor"

                    strokeLinejoin="round"                  strokeWidth="2"

                    className="h-4 w-4"                  strokeLinecap="round"

                  >                  strokeLinejoin="round"

                    <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/>                  className="h-4 w-4"

                    <path d="m15 5 4 4"/>                >

                  </svg>                  <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/>

                </Button>                  <path d="m15 5 4 4"/>

              )}                </svg>

              {isEditMode && (              </Button>

                <Button            )}

                  variant="outline"            {isEditMode && (

                  size="sm"              <Button

                  disabled={!content || saving}                variant="outline"

                  onClick={handleSuggestTitle}                size="sm"

                  className="flex items-center gap-2"                disabled={!content || saving}

                >                onClick={handleSuggestTitle}

                  <svg                className="flex items-center gap-2"

                    xmlns="http://www.w3.org/2000/svg"              >

                    viewBox="0 0 24 24"                <svg

                    fill="none"                  xmlns="http://www.w3.org/2000/svg"

                    stroke="currentColor"                  viewBox="0 0 24 24"

                    strokeWidth="2"                  fill="none"

                    strokeLinecap="round"                  stroke="currentColor"

                    strokeLinejoin="round"                  strokeWidth="2"

                    className="h-4 w-4"                  strokeLinecap="round"

                  >                  strokeLinejoin="round"

                    <path d="M15 4V2" />                  className="h-4 w-4"

                    <path d="M15 16v-2" />                >

                    <path d="M8 9h2" />                  <path d="M15 4V2" />

                    <path d="M20 9h2" />                  <path d="M15 16v-2" />

                    <path d="M17.8 11.8L19 13" />                  <path d="M8 9h2" />

                    <path d="M15 9h0" />                  <path d="M20 9h2" />

                    <path d="M17.8 6.2L19 5" />                  <path d="M17.8 11.8L19 13" />

                    <path d="M12.2 6.2L11 5" />                  <path d="M15 9h0" />

                    <path d="M12.2 11.8L11 13" />                  <path d="M17.8 6.2L19 5" />

                  </svg>                  <path d="M12.2 6.2L11 5" />

                  Suggest                  <path d="M12.2 11.8L11 13" />

                </Button>                </svg>

              )}                Suggest

            </div>              </Button>

            <div className="text-xs text-muted-foreground">            )}

              {saving ? "Saving..." : hasChanges ? "Unsaved changes" : "All changes saved"}                strokeLinejoin="round"

            </div>                className="h-4 w-4"

          </DialogHeader>              >

                <path d="M15 4V2" />

          <ScrollArea className="flex-1 p-4">                <path d="M15 16v-2" />

            {isEditMode ? (                <path d="M8 9h2" />

              <RichNoteEditor                <path d="M20 9h2" />

                value={content}                <path d="M17.8 11.8L19 13" />

                onChange={setContent}                <path d="M15 9h0" />

                placeholder="Write your note... (bold, italic, lists, tables, checklists)"                <path d="M17.8 6.2L19 5" />

              />                <path d="M12.2 6.2L11 5" />

            ) : (                <path d="M12.2 11.8L11 13" />

              <div className="prose prose-sm max-w-none" dangerouslySetInnerHTML={{ __html: content }} />              </svg>

            )}              Suggest

          </ScrollArea>            </Button>

          <div className="flex items-center justify-end gap-2 p-4 border-t">

            {isEditMode ? (          </div>

              <>          <div className="text-xs text-muted-foreground">

                <Button            {saving ? "Saving..." : hasChanges ? "Unsaved changes" : "All changes saved"}

                  variant="secondary"          </div>

                  size="sm"        </DialogHeader>

                  onClick={() => {

                    if (note) {        <ScrollArea className="flex-1 p-4">

                      setIsEditMode(false);          {isEditMode ? (

                      // Reset content if there are unsaved changes            <RichNoteEditor

                      if (hasChanges) {              value={content}

                        setTitle(note.title);              onChange={setContent}

                        setContent(note.content);              placeholder="Write your note... (bold, italic, lists, tables, checklists)"

                        setHasChanges(false);            />

                      }          ) : (

                    } else {            <div className="prose prose-sm max-w-none" dangerouslySetInnerHTML={{ __html: content }} />

                      onOpenChange(false);          )}

                    }        </ScrollArea>

                  }}        <div className="flex items-center justify-end gap-2 p-4 border-t">

                >          {isEditMode ? (

                  Cancel            <>

                </Button>              <Button

                <Button                variant="secondary"

                  variant="default"                size="sm"

                  size="sm"                onClick={() => {

                  disabled={saving}                  if (note) {

                  onClick={async () => {                    setIsEditMode(false);

                    const ok = await saveNote();                    // Reset content if there are unsaved changes

                    if (ok) {                    if (hasChanges) {

                      if (note) {                      setTitle(note.title);

                        setIsEditMode(false);                      setContent(note.content);

                      } else {                      setHasChanges(false);

                        onOpenChange(false);                    }

                      }                  } else {

                    }                    onOpenChange(false);

                  }}                  }

                >                }}

                  Save              >

                </Button>                Cancel

              </>              </Button>

            ) : (              <Button

              <Button                variant="default"

                variant="secondary"                size="sm"

                size="sm"                disabled={saving}

                onClick={() => onOpenChange(false)}                onClick={async () => {

              >                  const ok = await saveNote();

                Close                  if (ok) {

              </Button>                    if (note) {

            )}                      setIsEditMode(false);

          </div>                    } else {

        </DialogContent>                      onOpenChange(false);

      </Dialog>                    }

                  }

      <AlertDialog open={confirmClose} onOpenChange={setConfirmClose}>                }}

        <AlertDialogContent>              >

          <AlertDialogHeader>                Save

            <AlertDialogTitle>Unsaved changes</AlertDialogTitle>              </Button>

            <AlertDialogDescription>            </>

              You have unsaved changes. Would you like to save or discard them?          ) : (

            </AlertDialogDescription>            <Button

          </AlertDialogHeader>              variant="secondary"

          <AlertDialogFooter>              size="sm"

            <AlertDialogCancel onClick={() => setConfirmClose(false)}>Keep Editing</AlertDialogCancel>              onClick={() => onOpenChange(false)}

            <AlertDialogAction            >

              className="bg-muted text-foreground hover:bg-muted/80"              Close

              onClick={() => {            </Button>

                // Discard          )}

                if (note) {        </div>

                  setTitle(note.title);      </DialogContent>

                  setContent(note.content);      {/* Confirm close dialog */}

                } else {      <AlertDialog open={confirmClose} onOpenChange={setConfirmClose}>

                  setTitle("");        <AlertDialogContent>

                  setContent("");          <AlertDialogHeader>

                }            <AlertDialogTitle>Unsaved changes</AlertDialogTitle>

                setHasChanges(false);            <AlertDialogDescription>

                setConfirmClose(false);              You have unsaved changes. Would you like to save or discard them?

                onOpenChange(false);            </AlertDialogDescription>

              }}          </AlertDialogHeader>

            >          <AlertDialogFooter>

              Discard            <AlertDialogCancel onClick={() => setConfirmClose(false)}>Keep Editing</AlertDialogCancel>

            </AlertDialogAction>            <AlertDialogAction

            <AlertDialogAction              className="bg-muted text-foreground hover:bg-muted/80"

              onClick={async () => {              onClick={() => {

                const ok = await saveNote();                // Discard

                if (ok) {                if (note) {

                  setConfirmClose(false);                  setTitle(note.title);

                  onOpenChange(false);                  setContent(note.content);

                }                } else {

              }}                  setTitle("");

            >                  setContent("");

              Save                }

            </AlertDialogAction>                setHasChanges(false);

          </AlertDialogFooter>                setConfirmClose(false);

        </AlertDialogContent>                onOpenChange(false);

      </AlertDialog>              }}

    </>            >

  );              Discard

};            </AlertDialogAction>
            <AlertDialogAction
              onClick={async () => {
                const ok = await saveNote();
                if (ok) {
                  setConfirmClose(false);
                  onOpenChange(false);
                }
              }}
            >
              Save
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </Dialog>
  );
};
